<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Claudio — low-latency path</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0b0b0b;--panel:#151515;--text:#eaeaea;--muted:#9aa0a6;--ok:#22c55e;--warn:#f59e0b;--err:#ef4444;--accent:#60a5fa;
    }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px/1.4 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:980px;margin:32px auto;padding:0 16px}
    h1{font-weight:700;letter-spacing:.3px;margin:0 0 16px}
    .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
    input[type=text],select,button{background:#1f1f1f;border:1px solid #2a2a2a;color:var(--text);border-radius:10px;padding:10px 12px}
    select{min-width:260px}
    button{cursor:pointer}
    button.primary{background:rgba(96,165,250,.15);border-color:rgba(96,165,250,.35)}
    button.ok{background:rgba(34,197,94,.15);border-color:rgba(34,197,94,.35)}
    button.warn{background:rgba(245,158,11,.15);border-color:rgba(245,158,11,.35)}
    .pill{padding:8px 10px;border-radius:10px;background:#1a1a1a;border:1px solid #2a2a2a;color:var(--muted)}
    .meter{height:8px;background:#222;border-radius:6px;margin:8px 0;position:relative}
    .bar{position:absolute;left:0;top:0;bottom:0;width:0;background:linear-gradient(90deg,#34d399,#f59e0b,#ef4444);border-radius:6px}
    .tags{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
    .tag{background:#121212;border:1px solid #2a2a2a;padding:6px 10px;border-radius:999px;color:var(--muted)}
    pre{background:var(--panel);border:1px solid #262626;border-radius:12px;padding:12px;white-space:pre-wrap;min-height:120px}
    .right{margin-left:auto}
    .chk{display:flex;align-items:center;gap:8px;background:#151515;border:1px solid #2a2a2a;border-radius:10px;padding:8px 10px;color:var(--muted)}
    .small{font-size:12px;color:var(--muted)}
  </style>
  <!--
    Notes:
    • “Aggressive mode” pushes Chrome to minimal playout buffer (~20 ms) and tight Opus framing (ptime/maxptime 10 ms).
    • Talkback is a toggle now (click once to talk, click again to mute).
    • MacBook Air M1 built-in hardware (wired output + built-in mic) typically adds ~15–25 ms end-to-end
      (output DAC/driver ~5–12 ms + mic capture ~3–8 ms + OS buffering ~5–10 ms). Bluetooth adds 120–200 ms by itself.
  -->
</head>
<body>
  <div class="wrap">
    <h1>Claudio — low-latency path</h1>

    <div class="row">
      <select id="micSel"></select>
      <select id="spkSel"></select>
      <button id="refreshBtn" title="Refresh device list">Refresh devices</button>
      <span class="pill" id="rtt">rtt: –</span>
      <span class="pill" id="pathTag">path: –</span>
      <span class="pill" id="transportTag">transport: –</span>
      <label class="chk right" title="Use the most aggressive latency hints (can cause choppiness on weak networks)">
        <input type="checkbox" id="aggrChk" /> Aggressive mode
      </label>
    </div>

    <div class="row">
      <button id="enableBtn" class="primary">Enable sound</button>
      <button id="talkBtn" class="warn" disabled>Talkback: OFF</button>
      <button id="loopBtn">Start loopback</button>
      <button id="pingBtn">Ping</button>
    </div>

    <div class="meter" aria-label="input level"><div class="bar" id="vu"></div></div>

    <div class="tags">
      <span class="tag" id="statusSock">socket: –</span>
      <span class="tag" id="statusLoop">loopback: –</span>
      <span class="tag" id="statusWizard">wizard: –</span>
    </div>

    <pre id="log"></pre>
  </div>

  <audio id="sink" autoplay playsinline></audio>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ====== globals ======
    const logEl = document.getElementById('log');
    const vuBar = document.getElementById('vu');
    const sinkEl = document.getElementById('sink');
    const micSel = document.getElementById('micSel');
    const spkSel = document.getElementById('spkSel');
    const enableBtn = document.getElementById('enableBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const loopBtn = document.getElementById('loopBtn');
    const pingBtn = document.getElementById('pingBtn');
    const talkBtn = document.getElementById('talkBtn');
    const aggrChk = document.getElementById('aggrChk');

    const statusSock = document.getElementById('statusSock');
    const statusLoop = document.getElementById('statusLoop');
    const statusWizard = document.getElementById('statusWizard');
    const rttTag = document.getElementById('rtt');
    const pathTag = document.getElementById('pathTag');
    const transportTag = document.getElementById('transportTag');

    let socket = null;
    let micStream = null;
    let levelRAF = 0;
    let levelAnalyser = null;
    let pcSend = null, pcRecv = null;
    let loopRunning = false;
    let talkOn = false;
    let lastCand = {type:'-', protocol:'-'};

    // ====== utils ======
    function log(msg, type='info'){
      const color = type==='ok' ? '#22c55e' : type==='warn' ? '#f59e0b' : type==='err' ? '#ef4444' : '#9aa0a6';
      logEl.innerHTML += `%c${msg}\n`;
      console.log(msg);
      // colorize the newly added line
      const parts = logEl.innerHTML.split('%c');
      if (parts.length>1){
        logEl.innerHTML = '';
        for (let i=0;i<parts.length;i++){
          if (i===0) { logEl.append(parts[i]); continue; }
          const span = document.createElement('span');
          span.style.color = color;
          span.textContent = parts[i];
          logEl.appendChild(span);
        }
      }
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function listDevices() {
      const devs = await navigator.mediaDevices.enumerateDevices();
      const mics = devs.filter(d=>d.kind==='audioinput');
      const spks = devs.filter(d=>d.kind==='audiooutput');

      micSel.innerHTML = '';
      mics.forEach(d=>{
        const o = document.createElement('option');
        o.value = d.deviceId; o.textContent = d.label || `Mic ${micSel.length+1}`;
        micSel.appendChild(o);
      });

      spkSel.innerHTML = '';
      spks.forEach(d=>{
        const o = document.createElement('option');
        o.value = d.deviceId; o.textContent = d.label || `Output ${spkSel.length+1}`;
        spkSel.appendChild(o);
      });
    }

    function startLevelMeter(stream){
      const ac = new (window.AudioContext||window.webkitAudioContext)({ latencyHint:'interactive' });
      const src = ac.createMediaStreamSource(stream);
      levelAnalyser = ac.createAnalyser();
      levelAnalyser.fftSize = 512;
      src.connect(levelAnalyser);
      const data = new Uint8Array(levelAnalyser.fftSize);

      const tick = () => {
        levelAnalyser.getByteTimeDomainData(data);
        let sum = 0;
        for (let i=0;i<data.length;i++){
          const v = (data[i]-128)/128;
          sum += v*v;
        }
        const rms = Math.sqrt(sum/data.length);
        vuBar.style.width = Math.min(100, Math.round(rms*300)) + '%';
        levelRAF = requestAnimationFrame(tick);
      };
      cancelAnimationFrame(levelRAF);
      levelRAF = requestAnimationFrame(tick);
    }

    // ====== SDP tuning (low-latency safe) ======
    function tuneSDP(sdp, aggressive) {
      const parts = sdp.split('\r\nm=');
      for (let i = 1; i < parts.length; i++) {
        let sec = 'm=' + parts[i];
        if (sec.startsWith('m=audio')) {
          // a=ptime & a=maxptime at media level
          const wantP = aggressive ? 10 : 20;
          if (sec.match(/^a=ptime:/m)) sec = sec.replace(/^a=ptime:.*$/m, `a=ptime:${wantP}`);
          else sec = sec.replace(/(^a=rtpmap:.*\r\n)/m, `$1a=ptime:${wantP}\r\n`);

          if (sec.match(/^a=maxptime:/m)) sec = sec.replace(/^a=maxptime:.*$/m, `a=maxptime:${wantP}`);
          else sec = sec.replace(/(^a=ptime:.*\r\n)/m, `$1a=maxptime:${wantP}\r\n`);

          // opus fmtp
          const rtpmap = sec.match(/^a=rtpmap:(\d+)\s+opus\/48000\/?\d*/m);
          if (rtpmap) {
            const pt = rtpmap[1];
            const fmtpRe = new RegExp(`^a=fmtp:${pt}\\s+(.+)$`, 'm');
            const want = [
              'stereo=0',
              'useinbandfec=1',
              'usedtx=0',
              'maxaveragebitrate=128000'
            ];
            if (fmtpRe.test(sec)) {
              sec = sec.replace(fmtpRe, (m, p1) => {
                const have = p1.split(';').map(s=>s.trim()).filter(Boolean);
                const merged = new Map();
                for (const kv of have) { const [k,v] = kv.split('='); merged.set(k, v); }
                for (const kv of want) { const [k,v] = kv.split('='); merged.set(k, v); }
                const out = [...merged.entries()].map(([k,v])=>`${k}=${v}`).join(';');
                return `a=fmtp:${pt} ${out}`;
              });
            } else {
              sec = sec.replace(/^a=rtpmap:.*opus.*$/m, (line)=>`${line}\r\na=fmtp:${pt} ${want.join(';')}`);
            }
          }
        }
        parts[i] = sec.replace(/^m=/, '');
      }
      return parts.join('\r\nm=');
    }

    // ====== Loopback (send->recv on this page) ======
    async function startLoopback() {
      if (!micStream) { log('mic not ready','warn'); return; }

      // close previous
      pcSend?.close(); pcRecv?.close();

      const cfg = { iceServers:[{urls:'stun:stun.l.google.com:19302'}], iceCandidatePoolSize:2 };
      pcSend = new RTCPeerConnection(cfg);
      pcRecv = new RTCPeerConnection(cfg);

      pcSend.onicecandidate = e => e.candidate && pcRecv.addIceCandidate(e.candidate).catch(()=>{});
      pcRecv.onicecandidate = e => {
        if (e.candidate) {
          lastCand.type = (e.candidate.type||'-').toLowerCase();
          lastCand.protocol = (e.candidate.protocol||'-').toLowerCase();
          pathTag.textContent = 'path: ' + lastCand.type;
          transportTag.textContent = 'transport: ' + lastCand.protocol;
          pcSend.addIceCandidate(e.candidate).catch(()=>{});
        }
      };

      pcRecv.ontrack = () => {
        try {
          const rx = pcRecv.getReceivers().find(r=>r.track && r.track.kind==='audio');
          if (rx && 'playoutDelayHint' in rx) rx.playoutDelayHint = aggrChk.checked ? 0.02 : 0.06; // ~20ms or ~60ms
        } catch {}
        sinkEl.srcObject = pcRecv.getReceivers().map(r=>r.track).length ? pcRecv.getReceivers()[0].streams?.[0] : null;
      };

      // add mic track
      micStream.getAudioTracks().forEach(t=> pcSend.addTrack(t, micStream));

      // Offer/Answer with tuned SDP
      let offer = await pcSend.createOffer({ offerToReceiveAudio:false });
      offer = { type: offer.type, sdp: tuneSDP(offer.sdp, aggrChk.checked) };
      await pcSend.setLocalDescription(offer);
      await pcRecv.setRemoteDescription(offer);

      let answer = await pcRecv.createAnswer();
      answer = { type: answer.type, sdp: tuneSDP(answer.sdp, aggrChk.checked) };
      await pcRecv.setLocalDescription(answer);
      await pcSend.setRemoteDescription(answer);

      loopRunning = true;
      statusLoop.textContent = 'loopback: running';
      loopBtn.textContent = 'Restart loopback';
      log(`local loopback running (${aggrChk.checked ? 'aggressive' : 'normal'} mode)`, 'ok');
    }

    function toggleTalk() {
      if (!micStream) return;
      talkOn = !talkOn;
      micStream.getAudioTracks().forEach(t => t.enabled = talkOn);
      talkBtn.textContent = 'Talkback: ' + (talkOn ? 'ON' : 'OFF');
      talkBtn.className = talkOn ? 'ok' : 'warn';
      log('talkback ' + (talkOn ? 'ON' : 'OFF'));
    }

    // ====== Socket ping (server RTT) ======
    function initSocket() {
      try {
        socket = io({ transports:['websocket'], timeout:4000, reconnection:true });
        socket.on('connect', ()=>{
          statusSock.textContent = 'socket: connected';
        });
        socket.on('disconnect', ()=>{
          statusSock.textContent = 'socket: disconnected';
        });
      } catch (e) {
        log('socket failed: ' + e.message, 'warn');
      }
    }
    function doPing() {
      if (!socket || socket.disconnected) { rttTag.textContent = 'rtt: –'; return; }
      const ts = Date.now();
      socket.emit('ping', ts);
      const timer = setTimeout(()=> rttTag.textContent='rtt: timeout', 3000);
      socket.once('pong', ()=>{
        clearTimeout(timer);
        rttTag.textContent = 'rtt: ' + (Date.now()-ts) + 'ms';
      });
    }

    // ====== Device init ======
    async function enableAudio() {
      try {
        // request with browser-friendly constraints
        const devId = micSel.value || 'default';
        micStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            deviceId: devId === 'default' ? undefined : { exact: devId },
            channelCount: 1,
            sampleRate: { ideal: 48000 },
            sampleSize: { ideal: 16 },
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
          }
        });
        sinkEl.setSinkId && spkSel.value && sinkEl.setSinkId(spkSel.value).catch(()=>{});
        startLevelMeter(micStream);
        talkBtn.disabled = false;
        // default talk state OFF (tracks disabled) until toggled
        micStream.getAudioTracks().forEach(t=> t.enabled = false);
        log('mic ready','ok');
      } catch (e) {
        log('getUserMedia error: ' + e.message, 'err');
      }
    }

    async function refreshAll() {
      await listDevices();
      await enableAudio();
    }

    // ====== UI wiring ======
    enableBtn.onclick = enableAudio;
    refreshBtn.onclick = refreshAll;
    loopBtn.onclick = startLoopback;
    talkBtn.onclick = toggleTalk;
    pingBtn.onclick = doPing;
    aggrChk.onchange = () => { if (loopRunning) startLoopback(); };

    // ====== boot ======
    (async () => {
      statusWizard.textContent = 'wizard: ready';
      await listDevices();
      initSocket();
      // try to prefill labels (requires permission)
      try {
        await navigator.mediaDevices.getUserMedia({audio:true});
        await listDevices();
      } catch {}
      log('ready');
      // auto ping every 5s
      setInterval(doPing, 5000);
    })();
  </script>
</body>
</html>
