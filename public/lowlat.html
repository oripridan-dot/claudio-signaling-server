<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Claudio ‚Äî low-latency path</title>
<style>
  body{margin:0;background:#0b0b0b;color:#e6e6e6;font:15px/1.45 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto}
  .row{display:flex;gap:10px;flex-wrap:wrap;margin:14px}
  select,button,input{background:#1d1d1d;color:#e6e6e6;border:1px solid #333;border-radius:10px;padding:10px 12px}
  button{cursor:pointer}
  h1{font-weight:700;margin:16px 14px}
  .meter{height:10px;background:#222;border-radius:6px;overflow:hidden;margin:12px 14px}
  .bar{height:100%;width:0;background:linear-gradient(90deg,#22c55e,#f59e0b,#ef4444)}
  pre{background:#0f0f0f;border:1px solid #222;border-radius:8px;padding:10px;white-space:pre-wrap}
  .pill{padding:4px 8px;border-radius:999px;border:1px solid #333;background:#151515;font-size:12px}
  .good{color:#22c55e;border-color:#22c55e33}
  .warn{color:#f59e0b;border-color:#f59e0b33}
  .bad{color:#ef4444;border-color:#ef444433}
</style>
</head>
<body>
<h1>Claudio ‚Äî low-latency path</h1>

<div class="row">
  <input id="room" value="STUDIO1" style="min-width:120px" />
  <input id="name" value="musician" style="min-width:120px" />
  <button id="join">Join</button>
  <button id="ping">Ping</button>
  <span id="rtt" class="pill">rtt: ‚Äì</span>
  <span id="path" class="pill">path: ‚Äì</span>
  <span id="transport" class="pill">transport: ‚Äì</span>
</div>

<div class="row">
  <select id="mic"></select>
  <select id="sink"></select>
  <button id="refresh">Refresh devices</button>
</div>

<div class="row">
  <button id="enable">Enable sound</button>
  <button id="ptt" disabled>üéôÔ∏è hold to talk</button>
  <span id="peers" class="pill">peers: 0</span>
</div>

<div class="meter"><div id="vu" class="bar"></div></div>

<div class="row" style="flex-direction:column;gap:8px">
  <pre id="log">ready</pre>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const $ = id => document.getElementById(id);
const log = (...a)=>{$('log').textContent += "\n"+a.join(' ')};

let ac, outNode, micStream, sendStream, socket, pc, localSender, recv;
let sinkId = null, micId = null, started = false;

const SIGNAL_URL = location.origin.replace(/\/$/, '');
const ICE = [
  { urls: ['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478'] }
];

async function listDevices() {
  const devs = await navigator.mediaDevices.enumerateDevices();
  const mics = devs.filter(d=>d.kind==='audioinput');
  const outs = devs.filter(d=>d.kind==='audiooutput');
  $('mic').innerHTML  = mics.map(d=>`<option value="${d.deviceId}">${d.label||'Mic'}</option>`).join('');
  $('sink').innerHTML = outs.map(d=>`<option value="${d.deviceId}">${d.label||'Output'}</option>`).join('');
}

async function enableAudio() {
  micId = $('mic').value || undefined;

  ac = new (window.AudioContext || window.webkitAudioContext)({
    latencyHint: 'interactive',
    sampleRate: 48000
  });

  const gum = {
    audio: {
      deviceId: micId ? {exact: micId} : undefined,
      channelCount: {ideal: 1, max: 1},
      sampleRate: {ideal: 48000},
      sampleSize: {ideal: 16},
      echoCancellation: false,
      noiseSuppression: false,
      autoGainControl: false,
      latency: {ideal: 0}
    }
  };

  micStream = await navigator.mediaDevices.getUserMedia(gum);
  sendStream = new MediaStream([micStream.getAudioTracks()[0]]);

  const src = ac.createMediaStreamSource(sendStream);
  outNode = ac.createMediaStreamDestination();
  src.connect(outNode);

  const el = new Audio();
  el.srcObject = outNode.stream;
  el.muted = true; // keep muted; remote audio will play automatically
  if ('setSinkId' in el && $('sink').value) {
    await el.setSinkId($('sink').value).catch(()=>{});
  }
  await el.play().catch(()=>{});

  $('ptt').disabled = false;
  started = true;
  log('mic ready');

  // VU
  const analyser = ac.createAnalyser(); analyser.fftSize = 512;
  src.connect(analyser);
  const data = new Uint8Array(analyser.frequencyBinCount);
  const vu = $('vu');
  (function draw(){
    analyser.getByteTimeDomainData(data);
    let peak = 0;
    for (let i=0;i<data.length;i++){
      const v = Math.abs(data[i]-128)/128;
      if (v>peak) peak=v;
    }
    vu.style.width = Math.min(100, Math.round(peak*200))+'%';
    requestAnimationFrame(draw);
  })();
}

// ---- FIXED SDP MUNGE (put Opus params on fmtp & add ptime lines) ----
function mungeOpus(sdp) {
  const lines = sdp.split('\r\n');

  // find opus payload type from "a=rtpmap:<pt> opus/48000"
  let opusPt = null;
  for (const line of lines) {
    const m = line.match(/^a=rtpmap:(\d+)\s+opus\/48000/i);
    if (m) { opusPt = m[1]; break; }
  }
  if (!opusPt) return sdp; // nothing to do

  // remove existing fmtp for this pt
  const out = lines.filter(l => !new RegExp(`^a=fmtp:${opusPt}\\b`).test(l));

  // insert our fmtp just after rtpmap
  const rtpmapIdx = out.findIndex(l => new RegExp(`^a=rtpmap:${opusPt}\\b`).test(l));
  const fmtp = `a=fmtp:${opusPt} minptime=10;maxptime=10;maxaveragebitrate=128000;stereo=0;useinbandfec=0`;

  if (rtpmapIdx !== -1) out.splice(rtpmapIdx+1, 0, fmtp);
  else out.push(fmtp);

  // ensure a=ptime/maxptime exist (once) in the audio media section
  // simple approach: append near the end
  if (!out.some(l => /^a=ptime:/.test(l))) out.push('a=ptime:10');
  if (!out.some(l => /^a=maxptime:/.test(l))) out.push('a=maxptime:10');

  return out.join('\r\n');
}

async function startPeer() {
  pc = new RTCPeerConnection({iceServers: ICE, bundlePolicy:'max-bundle'});

  pc.onconnectionstatechange = ()=>log('pc state', pc.connectionState);
  pc.oniceconnectionstatechange = ()=>log('ice', pc.iceConnectionState);
  pc.onicecandidateerror = e=>log('ice err', e.errorText||e.error||e.type);

  localSender = pc.addTrack(sendStream.getAudioTracks()[0], sendStream);

  pc.ontrack = ev => {
    const a = new Audio();
    a.autoplay = true;
    a.srcObject = new MediaStream([ev.track]);
    if ('setSinkId' in a && $('sink').value) a.setSinkId($('sink').value).catch(()=>{});
    try { ev.receiver.playoutDelayHint = 0.02; } catch {}
  };

  const tx = pc.getTransceivers()[0];
  if (tx && window.RTCRtpSender && tx.setCodecPreferences) {
    const c = RTCRtpSender.getCapabilities('audio').codecs
      .filter(x => /opus/i.test(x.mimeType));
    if (c.length) tx.setCodecPreferences(c);
  }

  // signaling
  socket = io(SIGNAL_URL, {transports:['websocket']});
  socket.on('connect', ()=>log('socket connected'));
  socket.on('users', u=>$('peers').textContent=`peers: ${Math.max(0,u-1)}`);
  socket.on('pongstamp', t=>{
    const ms = Date.now()-t;
    const r = $('rtt');
    r.textContent = `rtt: ${ms}ms`;
    r.className = 'pill ' + (ms<25?'good':ms<60?'warn':'bad');
  });

  socket.on('sdp', async msg => {
    if (msg.type==='offer') {
      await pc.setRemoteDescription(msg.desc);
      const ans = await pc.createAnswer();
      await pc.setLocalDescription(ans);
      socket.emit('sdp', {type:'answer', desc: pc.localDescription});
    } else if (msg.type==='answer') {
      await pc.setRemoteDescription(msg.desc);
    }
  });
  socket.on('ice', async c => { try { await pc.addIceCandidate(c); } catch(e){ log('addIce err', e.message); } });
  pc.onicecandidate = e => { if (e.candidate) socket.emit('ice', e.candidate); };

  // log selected candidate & transport
  setInterval(async ()=>{
    if (!pc) return;
    const stats = await pc.getStats();
    stats.forEach(r=>{
      if (r.type==='transport' && r.selectedCandidatePairId) {
        const pair = stats.get(r.selectedCandidatePairId);
        if (pair) {
          const l = stats.get(pair.localCandidateId);
          const rmt = stats.get(pair.remoteCandidateId);
          $('path').textContent = `path: ${rmt?.candidateType||'?'}`;
          $('transport').textContent = `transport: ${l?.protocol||'?'}`;
        }
      }
    });
  }, 700);

  // join & offer
  socket.emit('join', {room:$('room').value, name:$('name').value});
  let offer = await pc.createOffer({offerToReceiveAudio:true});
  offer = new RTCSessionDescription({type:'offer', sdp: mungeOpus(offer.sdp)});
  await pc.setLocalDescription(offer);
  socket.emit('sdp', {type:'offer', desc: pc.localDescription});
}

$('refresh').onclick = listDevices;
$('enable').onclick  = enableAudio;
$('join').onclick    = async ()=>{ if(!started) await enableAudio(); await startPeer(); };
$('ping').onclick    = ()=>{ socket?.emit('pingstamp', Date.now()); };

$('ptt').onmousedown = ()=>{ if (localSender) localSender.replaceTrack(micStream.getAudioTracks()[0]); };
$('ptt').onmouseup   = ()=>{ if (localSender) localSender.replaceTrack(null); };
$('ptt').ontouchstart = e=>{ e.preventDefault(); $('ptt').onmousedown(); };
$('ptt').ontouchend   = e=>{ e.preventDefault(); $('ptt').onmouseup(); };

navigator.mediaDevices.ondevicechange = listDevices;
listDevices();
</script>
</body>
</html>
