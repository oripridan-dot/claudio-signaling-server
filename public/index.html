<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Claudio ‚Äî audio path test (silent-track fix)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#0a0a0a; --card:#171717; --text:#e5e7eb; --muted:#9ca3af; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
    *{box-sizing:border-box} body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)}
    .wrap{max-width:760px;margin:0 auto;padding:24px} h1{margin:0 0 10px}
    .card{background:var(--card);border:1px solid #262626;border-radius:12px;padding:16px;margin:12px 0}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    input,select{background:#101010;color:var(--text);border:1px solid #2a2a2a;padding:10px 12px;border-radius:8px}
    button{background:#0f172a;color:#cbd5e1;border:1px solid #334155;padding:10px 14px;border-radius:8px;cursor:pointer}
    button:hover{border-color:#475569} button.primary{background:#0b1220;border-color:#1e3a8a;color:#dbeafe}
    button.danger{background:#2a0f12;border-color:#7f1d1d;color:#fecaca}
    .pill{padding:4px 8px;border-radius:999px;background:#111827;border:1px solid #1f2937;color:#9ca3af}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)} .muted{color:var(--muted)}
    .log{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;background:#0b0b0b;border:1px solid #1f2937;border-radius:8px;padding:10px;height:140px;overflow:auto}
    .users{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .meter{height:14px;background:#0b0b0b;border:1px solid #1f2937;border-radius:7px;overflow:hidden}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,#22c55e,#f59e0b,#ef4444)}
    .spacer{flex:1}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Claudio ‚Äî audio path test (silent-track fix)</h1>
    <div id="status" class="pill">socket: connecting‚Ä¶</div>

    <!-- Devices -->
    <div class="card">
      <div class="row">
        <label>Mic</label><select id="inDev" style="min-width:260px"></select>
        <label>Output</label><select id="outDev" style="min-width:260px"></select>
        <button onclick="refreshDevices()">Refresh</button>
        <button onclick="enableSound()">Enable sound</button>
        <button onclick="playTone()">Test tone</button>
      </div>
      <div class="row" style="margin-top:8px">
        <div class="meter" style="flex:1"><div id="inVU" class="bar"></div></div><span class="muted">incoming level</span>
      </div>
    </div>

    <!-- Join / PTT -->
    <div class="card">
      <div class="row">
        <input id="room" placeholder="room" value="STUDIO1" maxlength="12" />
        <input id="name" placeholder="name" value="musician" maxlength="20" />
        <button class="primary" onclick="join()">Join</button>
        <div class="spacer"></div>
        <button onclick="ping()">Ping</button><span id="rtt" class="pill">rtt: ‚Äî</span>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="ptt" class="danger" onmousedown="pttStart()" onmouseup="pttStop()"
                ontouchstart="pttStart(event)" ontouchend="pttStop(event)">üéôÔ∏è Talk (hold)</button>
        <span class="muted">Hold to send your mic</span>
      </div>
    </div>

    <!-- Users / Debug -->
    <div class="card"><b>Users</b><div id="users" class="users">‚Äî</div></div>
    <div class="card"><b>Debug</b><div id="debug" class="log"></div></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ===== Globals =====
    let socket=null, roomId=null, audioUnlocked=false;
    let localStream=null, localTrack=null, silentTrack=null;
    let inAnalyser=null, inBuf=null, rafVU=null;

    const peers=new Map(), senders=new Map(), audios=new Map();
    const rtcConfig={ iceServers:[{urls:'stun:stun.l.google.com:19302'}] };

    const el=id=>document.getElementById(id);
    function log(...a){ const d=el('debug'); d.textContent += a.map(x=>typeof x==='string'?x:JSON.stringify(x)).join(' ') + "\n"; d.scrollTop=d.scrollHeight; }
    function setStatus(t,c=''){ const n=el('status'); n.textContent=t; n.className='pill '+c; }
    function listUsers(u){ el('users').textContent=(u||[]).map(x=>`${x.username}${x.id===socket.id?' (you)':''}`).join(' | ') || '‚Äî'; }

    // ===== AudioContext (shared) =====
    let ctx=null;
    async function ensureCtx(){
      if (!ctx) ctx = new (window.AudioContext||window.webkitAudioContext)({ sampleRate: 48000 });
      if (ctx.state==='suspended') await ctx.resume();
      return ctx;
    }

    // ===== Silent track (placeholder) =====
    async function getSilentTrack(){
      if (silentTrack) return silentTrack;
      const ac = await ensureCtx();
      const osc = ac.createOscillator();        // any source‚Ä¶
      const gain = ac.createGain();
      gain.gain.value = 0.0;                    // ‚Ä¶but fully muted
      const dst = ac.createMediaStreamDestination();
      osc.connect(gain).connect(dst);
      osc.start();
      silentTrack = dst.stream.getAudioTracks()[0];
      silentTrack.enabled = true;
      log('silent track ready');
      return silentTrack;
    }

    // ===== Devices =====
    async function refreshDevices(){
      try{
        const devs = await navigator.mediaDevices.enumerateDevices();
        const mics = devs.filter(d=>d.kind==='audioinput');
        const outs = devs.filter(d=>d.kind==='audiooutput');
        const inSel = el('inDev'), outSel=el('outDev');
        inSel.innerHTML = mics.map(d=>`<option value="${d.deviceId}">${d.label||'mic'}</option>`).join('');
        outSel.innerHTML = outs.map(d=>`<option value="${d.deviceId}">${d.label||'speaker'}</option>`).join('');
        [...outSel.options].forEach(o=>{ if(/bose|airpods|headphones/i.test(o.text)) outSel.value=o.value; });
      }catch(e){ log('enumerate error', e.message||e); }
    }

    async function enableSound(){
      try{
        await ensureCtx();
        audioUnlocked=true;
        document.addEventListener('click', ()=>audios.forEach(a=>a.play().catch(()=>{})), { once:true, capture:true });
        await refreshDevices();
        log('sound unlocked');
      }catch(e){ log('unlock error', e.message||e); }
    }

    async function playTone(){
      try{
        const ac = await ensureCtx();
        const osc=ac.createOscillator(), g=ac.createGain();
        osc.frequency.value=440; g.gain.value=0.15; osc.connect(g).connect(ac.destination); osc.start();
        setTimeout(()=>{ osc.stop(); }, 600);
      }catch(e){ log('tone error', e.message||e); }
    }

    // ===== Mic / VU =====
    async function ensureMic(){
      if (localTrack) return;
      const devId = el('inDev').value || undefined;
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          deviceId: devId ? { exact: devId } : undefined,
          channelCount:1, sampleRate:48000, echoCancellation:false, noiseSuppression:false, autoGainControl:false
        }, video:false
      });
      localStream = stream;
      localTrack  = stream.getAudioTracks()[0];
      log('mic ready', JSON.stringify(localTrack.getSettings()));

      const ac = await ensureCtx();
      inAnalyser = ac.createAnalyser(); inAnalyser.fftSize=1024; inBuf = new Float32Array(inAnalyser.fftSize);
      startVU();
    }

    function startVU(){
      cancelAnimationFrame(rafVU);
      const bar = el('inVU');
      const loop=()=>{
        if (inAnalyser){
          inAnalyser.getFloatTimeDomainData(inBuf);
          let sum=0; for (let i=0;i<inBuf.length;i++){ const v=inBuf[i]; sum+=v*v; }
          const rms=Math.sqrt(sum/inBuf.length); const db = 20*Math.log10(rms||1e-8);
          const pct=Math.min(100,Math.max(0,100*(db+60)/60)); bar.style.width=pct+'%';
        }
        rafVU=requestAnimationFrame(loop);
      };
      loop();
    }

    // ===== Signaling =====
    function bootSocket(){
      socket = io({ transports:['websocket','polling'], reconnection:true });
      socket.on('connect', ()=> setStatus('socket: connected','ok'));
      socket.on('disconnect', ()=> setStatus('socket: disconnected','bad'));
      socket.on('connect_error', e=>{ setStatus('socket: error','bad'); log('connect_error', e.message||e); });

      socket.on('joined-room', ({ roomId:rid, users })=>{
        roomId=rid; listUsers(users); log('joined', rid);
        // Joiner never offers; existing peers will offer to us.
      });
      socket.on('user-joined', ({ user, users })=>{
        listUsers(users);
        if (user.id!==socket.id) createOfferTo(user.id); // we were here -> we initiate
      });
      socket.on('user-left', ({ id })=> destroyPeer(id));
      socket.on('users-updated', ({ users })=> listUsers(users));

      socket.on('pong', ts=>{
        const ms=Date.now()-ts, cls=ms<20?'ok':ms<50?'warn':'bad';
        el('rtt').textContent=`rtt: ${ms}ms`; el('rtt').className='pill '+cls;
      });

      socket.on('signal', async ({ from, data })=>{
        let pc = peers.get(from); if (!pc) pc=await createPeer(from,false);
        try{
          if (data.sdp){
            await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            if (data.sdp.type==='offer'){
              const ans=await pc.createAnswer(); await pc.setLocalDescription(ans);
              socket.emit('signal', { to: from, roomId, data:{ sdp: pc.localDescription } });
              log('answered to', from);
            }
          } else if (data.candidate){
            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
          }
        }catch(e){ log('signal error', e.message||e); }
      });
    }

    function join(){
      const rid=el('room').value.trim().toUpperCase();
      const name=el('name').value.trim()||'user';
      socket.emit('join-room',{ roomId:rid, username:name, instrument:'guitar' });
    }
    function ping(){ el('rtt').textContent='rtt: ‚Ä¶'; socket.emit('ping', Date.now()); }

    // ===== PTT =====
    async function pttStart(e){
      if (e) e.preventDefault();
      if (!roomId) return;
      el('ptt').disabled=true;
      try{
        await ensureMic();
        for (const sender of senders.values()){ await sender.replaceTrack(localTrack); }
        if (audioUnlocked) audios.forEach(a=>a.play().catch(()=>{}));
        socket.emit('toggle-audio', true);
      }catch(err){ log('pttStart error', err.message||err); }
      el('ptt').disabled=false;
    }
    async function pttStop(e){
      if (e) e.preventDefault();
      const sTrack = await getSilentTrack();
      for (const sender of senders.values()){ try{ await sender.replaceTrack(sTrack); }catch{} }
      socket.emit('toggle-audio', false);
    }

    // ===== WebRTC =====
    async function createPeer(peerId, initiator){
      const pc=new RTCPeerConnection(rtcConfig); peers.set(peerId, pc);

      // Create transceiver and immediately attach a SILENT track so the m-line is active
      const tx = pc.addTransceiver('audio', { direction:'sendrecv' });
      const sTrack = await getSilentTrack();
      try { await tx.sender.replaceTrack(sTrack); } catch(_) {}
      senders.set(peerId, tx.sender);

      pc.onicecandidate = e=>{ if(e.candidate) socket.emit('signal',{ to:peerId, roomId, data:{ candidate:e.candidate } }); };
      pc.onconnectionstatechange = ()=> log('pc', peerId, pc.connectionState);
      pc.oniceconnectionstatechange = ()=> log('ice', peerId, pc.iceConnectionState);
      pc.ontrack = ev=>{
        let a = audios.get(peerId);
        if (!a){ a=document.createElement('audio'); a.autoplay=true; a.playsInline=true; a.volume=1.0; document.body.appendChild(a); audios.set(peerId,a); }
        a.srcObject = ev.streams[0];

        // route to chosen OUTPUT (sinkId)
        const outId = el('outDev').value;
        if (a.setSinkId && outId){ a.setSinkId(outId).then(()=>log('sink ->', outId)).catch(e=>log('sinkId err', e.name)); }

        // feed analyser for incoming VU
        ensureCtx().then(ac=>{
          try{ const src = ac.createMediaStreamSource(ev.streams[0]); inAnalyser && src.connect(inAnalyser); }catch(_){}
        });

        a.play().catch(()=>{}); // may still need Enable sound
        log('ontrack from', peerId);
      };

      if (initiator){
        const offer=await pc.createOffer({ offerToReceiveAudio:true, offerToReceiveVideo:false });
        await pc.setLocalDescription(offer);
        socket.emit('signal',{ to:peerId, roomId, data:{ sdp: pc.localDescription } });
        log('offer ->', peerId);
      }
      return pc;
    }

    async function createOfferTo(peerId){
      if (peers.has(peerId)) return peers.get(peerId);
      return createPeer(peerId,true);
    }

    function destroyPeer(peerId){
      const pc=peers.get(peerId); if (pc){ try{pc.close();}catch{} }
      peers.delete(peerId); senders.delete(peerId);
      const a=audios.get(peerId); if (a){ a.srcObject=null; a.remove(); audios.delete(peerId); }
    }

    // ===== Boot =====
    document.addEventListener('DOMContentLoaded', ()=>{
      bootSocket();
      el('room').addEventListener('input', e=>{
        const v=e.target.value.toUpperCase().replace(/[^A-Z0-9]/g,'').slice(0,12);
        if (v!==e.target.value) e.target.value=v;
      });
      el('ptt').addEventListener('contextmenu', e=>e.preventDefault());
      refreshDevices().catch(()=>{});
    });
  </script>
</body>
</html>
