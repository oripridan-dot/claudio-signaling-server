<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Claudio ‚Äî sanity test (low-latency, multi-peer)</title>
  <style>
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;background:#0a0a0a;color:#e5e5e5}
    .wrap{max-width:960px;margin:24px auto;padding:24px}
    h1{margin:0 0 12px 0;font-weight:700;letter-spacing:.2px}
    .row{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0}
    input,button,select{background:#171717;color:#e5e5e5;border:1px solid #2a2a2a;border-radius:10px;padding:10px 12px}
    button{cursor:pointer} button:disabled{opacity:.5;cursor:not-allowed}
    .log{background:#0d0d0d;border:1px solid #252525;border-radius:10px;padding:8px;height:180px;overflow:auto;font:12px ui-monospace,Menlo,Consolas,monospace;white-space:pre}
    .meter{height:10px;background:#222;border:1px solid #333;border-radius:6px;overflow:hidden}
    .bar{height:100%;width:0;background:linear-gradient(90deg,#43e,#3c8,#fc3,#f44)}
    .ok{color:#22c55e}.warn{color:#f59e0b}.err{color:#ef4444}
    .pill{padding:6px 8px;border:1px solid #2a2a2a;border-radius:999px;background:#121212;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Claudio ‚Äî sanity test</h1>

    <div class="row">
      <input id="room" value="STUDIO1" />
      <input id="name" value="musician" />
      <button id="join">Join</button>
      <button id="ping">Ping</button>
      <span id="rtt" class="pill">rtt: ‚Äî</span>
    </div>

    <div class="row">
      <select id="mic"></select>
      <select id="out"></select>
      <button id="refresh">Refresh devices</button>
    </div>

    <div class="row">
      <button id="enable">Enable sound</button>
      <button id="talk" disabled>üéôÔ∏è Hold to talk</button>
      <span id="peerc" class="pill">peers: 0</span>
    </div>

    <div class="row"><div class="meter" style="flex:1"><div id="bar" class="bar"></div></div></div>

    <div class="row">
      <div id="log" class="log"></div>
    </div>

    <!-- remote sinks (hidden) -->
    <div id="sinks" style="display:none"></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const $ = id => document.getElementById(id);
    const log = (m,c='') => { const el=$('log'); const d=document.createElement('div'); if(c)d.className=c; d.textContent=m; el.appendChild(d); el.scrollTop=el.scrollHeight; };

    let roomId = 'STUDIO1';
    let socket, selfId;
    let users = [];
    // peers: id -> { pc, audioEl, sender, queued: RTCIceCandidateInit[] }
    const peers = new Map();
    let stream;

    // ---------- ICE / RTC config ----------
    const rtcConfig = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
      iceCandidatePoolSize: 8
    };

    // ---------- devices ----------
    async function listDevices(){
      const devs = await navigator.mediaDevices.enumerateDevices();
      const mics = devs.filter(d=>d.kind==='audioinput');
      const outs = devs.filter(d=>d.kind==='audiooutput');
      $('mic').innerHTML = mics.map(d=>`<option value="${d.deviceId}">${d.label||'Microphone'}</option>`).join('');
      $('out').innerHTML = outs.map(d=>`<option value="${d.deviceId}">${d.label||'Output'}</option>`).join('');
    }

    async function getMic(){
      const id = $('mic').value || undefined;
      const s = await navigator.mediaDevices.getUserMedia({
        audio: {
          deviceId: id ? {exact:id} : undefined,
          channelCount: 1,
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 48000,
          sampleSize: 16
        }
      });
      return s;
    }

    function setupLevelMeter(src){
      const AC = window.AudioContext || window.webkitAudioContext;
      const ac = new AC({ latencyHint: 'interactive' });
      const node = ac.createMediaStreamSource(src);
      const analyser = ac.createAnalyser();
      analyser.fftSize = 1024;
      const data = new Uint8Array(analyser.frequencyBinCount);
      node.connect(analyser);
      function tick(){
        analyser.getByteTimeDomainData(data);
        let sum=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; }
        const rms = Math.sqrt(sum/data.length);
        $('bar').style.width = Math.min(100, rms*200).toFixed(1)+'%';
        requestAnimationFrame(tick);
      }
      tick();
    }

    // ---------- SDP munging for low latency ----------
    function tuneOpus(sdp){
      // ensure ptime 10ms, FEC on, low delay
      const m = /a=rtpmap:(\d+)\s+opus\/48000\/2/i.exec(sdp) || /a=rtpmap:(\d+)\s+opus\/48000/i.exec(sdp);
      if (!m) return sdp;
      const pt = m[1];
      const fmtpRe = new RegExp(`a=fmtp:${pt} (.*)`);
      if (fmtpRe.test(sdp)) {
        sdp = sdp.replace(fmtpRe, (line, p) => {
          const params = new URLSearchParams(p.replace(/;/g,'&'));
          params.set('stereo','0');
          params.set('useinbandfec','1');
          params.set('minptime','10');
          params.set('maxplaybackrate','48000');
          params.set('ptime','10');
          // keep bitrate modest to reduce jitter (tune later as needed)
          params.set('maxaveragebitrate','96000');
          return `a=fmtp:${pt} `+params.toString().replace(/&/g,';');
        });
      } else {
        sdp = sdp.replace(/a=rtpmap:/, `a=fmtp:${pt} stereo=0;useinbandfec=1;minptime=10;maxplaybackrate=48000;ptime=10;maxaveragebitrate=96000\r\na=rtpmap:`);
      }
      // enforce packet times on m=audio section
      sdp = sdp.replace(/a=ptime:\d+/g,'a=ptime:10');
      if (!/a=ptime:10/.test(sdp)) sdp = sdp.replace(/m=audio .+?\r\n/, m => m + 'a=ptime:10\r\n');
      return sdp;
    }

    // ---------- socket wiring ----------
    function wireSocket(){
      socket = io({ transports:['websocket','polling'] });
      socket.on('connect', ()=> log('socket connected','ok'));
      socket.on('disconnect', r => log('socket disconnected: '+r,'warn'));
      socket.on('pong', ts => $('rtt').textContent = 'rtt: '+(Date.now()-ts)+'ms');

      socket.on('joined-room', ({roomId:rid, users:us, selfId:me}) => {
        roomId = rid; users = us; selfId = me;
        $('peerc').textContent = 'peers: '+(users.length-1);
        log(`joined ${rid} users:${users.length}`,'ok');
      });

      socket.on('users-updated', ({users:us}) => {
        users = us;
        $('peerc').textContent = 'peers: '+(users.length-1);
        log('users: '+users.map(u=>u.username||u.id).join(', '));
        // pre-create peer shells so we can queue candidates safely
        for (const u of users) if (u.id !== selfId && !peers.get(u.id)) createPeer(u.id);
      });

      socket.on('user-left', ({id}) => closePeer(id));

      // main signaling
      socket.on('signal', async ({from, data}) => {
        let peer = peers.get(from);
        if (!peer) peer = await createPeer(from);

        try {
          if (data.sdp) {
            const desc = new RTCSessionDescription(data.sdp);
            if (desc.type === 'offer') {
              await peer.pc.setRemoteDescription(desc);
              // drain queued candidates now that we have a remote description
              await flushQueued(peer);
              let answer = await peer.pc.createAnswer({ offerToReceiveAudio: true });
              // tune SDP
              answer.sdp = tuneOpus(answer.sdp);
              await peer.pc.setLocalDescription(answer);
              socket.emit('signal', { to: from, roomId, data: { sdp: peer.pc.localDescription } });
            } else if (desc.type === 'answer') {
              await peer.pc.setRemoteDescription(desc);
              await flushQueued(peer);
            }
          } else if (data.candidate) {
            // queue until we have a remoteDescription
            if (!peer.pc.remoteDescription) {
              peer.queued.push(data.candidate);
            } else {
              await peer.pc.addIceCandidate(data.candidate);
            }
          }
        } catch (e) {
          log('signal err '+e.message,'err');
        }
      });
    }

    async function flushQueued(peer){
      while (peer.queued.length){
        const c = peer.queued.shift();
        try{ await peer.pc.addIceCandidate(c); }catch(e){ log('ice late err '+e.message,'err'); }
      }
    }

    // ---------- webrtc ----------
    async function createPeer(remoteId){
      const pc = new RTCPeerConnection(rtcConfig);

      // remote playback
      const audioEl = document.createElement('audio');
      audioEl.autoplay = true;
      const sinkId = $('out').value;
      if (typeof audioEl.setSinkId === 'function' && sinkId) {
        try { await audioEl.setSinkId(sinkId); } catch {}
      }
      $('sinks').appendChild(audioEl);

      pc.ontrack = (ev) => { audioEl.srcObject = ev.streams[0]; };

      pc.onicecandidate = (ev) => {
        if (ev.candidate) {
          socket.emit('signal', { to: remoteId ?? '*', roomId, data: { candidate: ev.candidate } });
        }
      };

      pc.onconnectionstatechange = () => {
        const st = pc.connectionState;
        if (st === 'failed' || st === 'disconnected' || st === 'closed') closePeer(remoteId);
      };

      const obj = { pc, audioEl, sender: null, queued: [] };
      peers.set(remoteId, obj);
      return obj;
    }

    function closePeer(id){
      const p = peers.get(id);
      if (!p) return;
      try { p.pc.getSenders().forEach(s => { try{ p.pc.removeTrack(s); }catch{} }); } catch {}
      try { p.pc.close(); } catch {}
      try { p.audioEl.srcObject = null; p.audioEl.remove(); } catch {}
      peers.delete(id);
      $('peerc').textContent = 'peers: '+(users.length-1);
    }

    async function startTalking(){
      if (!stream) return;

      const others = users.filter(u => u.id !== selfId);
      for (const u of others) {
        let peer = peers.get(u.id);
        if (!peer) peer = await createPeer(u.id);
        if (!peer.sender) {
          const track = stream.getAudioTracks()[0];
          peer.sender = peer.pc.addTrack(track, stream);
        }
        let offer = await peer.pc.createOffer({ offerToReceiveAudio: true });
        offer.sdp = tuneOpus(offer.sdp);
        await peer.pc.setLocalDescription(offer);
        socket.emit('signal', { to: u.id, roomId, data: { sdp: peer.pc.localDescription } });
      }
    }

    function stopTalking(){
      for (const [id,p] of peers) {
        try { p.pc.getSenders().forEach(s => { try{ p.pc.removeTrack(s); }catch{} }); } catch {}
        p.sender = null;
      }
    }

    // ---------- UI ----------
    $('refresh').onclick = listDevices;
    $('enable').onclick = async () => {
      try {
        stream = await getMic();
        setupLevelMeter(stream);
        $('talk').disabled = false;
        log('mic ready','ok');
      } catch (e) { log('enable failed: '+e.message,'err'); }
    };
    $('join').onclick = () => {
      roomId = $('room').value.trim().toUpperCase();
      const username = $('name').value.trim() || 'musician';
      socket.emit('join-room', { roomId, username, instrument: 'guitar' });
    };
    $('ping').onclick = () => socket.emit('ping', Date.now());

    // push-to-talk
    $('talk').onmousedown = startTalking;
    $('talk').onmouseup   = stopTalking;
    $('talk').ontouchstart = (e)=>{ e.preventDefault(); startTalking(); };
    $('talk').ontouchend   = (e)=>{ e.preventDefault(); stopTalking(); };

    // boot
    (async ()=>{
      try { await navigator.mediaDevices.getUserMedia({audio:true}); } catch {}
      await listDevices();
      wireSocket();
    })();
  </script>
</body>
</html>
