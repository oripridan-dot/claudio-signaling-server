<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Claudio ‚Äî minimal audio test</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#0a0a0a; --card:#171717; --text:#e5e7eb; --muted:#9ca3af; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; --pri:#3b82f6; }
    * { box-sizing:border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:var(--bg); color:var(--text); }
    .wrap { max-width:680px; margin:0 auto; padding:24px; }
    h1 { font-weight:600; margin:0 0 10px; }
    .card { background:var(--card); border:1px solid #262626; border-radius:12px; padding:16px; margin:12px 0; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    input { background:#101010; color:var(--text); border:1px solid #2a2a2a; padding:10px 12px; border-radius:8px; }
    button { background:#0f172a; color:#cbd5e1; border:1px solid #334155; padding:10px 14px; border-radius:8px; cursor:pointer; }
    button:hover { border-color:#475569; }
    button.primary { background:#0b1220; border-color:#1e3a8a; color:#dbeafe; }
    button.danger { background:#2a0f12; border-color:#7f1d1d; color:#fecaca; }
    .pill { padding:4px 8px; border-radius:999px; background:#111827; border:1px solid #1f2937; color:#9ca3af; }
    .ok { color:var(--ok); } .warn { color:var(--warn); } .bad { color:var(--bad); }
    .muted { color:var(--muted); }
    .log { font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px;
      background:#0b0b0b; border:1px solid #1f2937; border-radius:8px; padding:10px; height:150px; overflow:auto; }
    .users { font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .spacer { flex:1; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Claudio ‚Äî minimal audio test</h1>
    <div id="status" class="pill">socket: connecting‚Ä¶</div>

    <div class="card">
      <div class="row">
        <input id="room" placeholder="room" value="STUDIO1" maxlength="12" />
        <input id="name" placeholder="name" value="musician" maxlength="20" />
        <button class="primary" onclick="join()">Join</button>
        <button onclick="enableSound()">Enable sound</button>
        <div class="spacer"></div>
        <button onclick="ping()">Ping</button>
        <span id="rtt" class="pill">rtt: ‚Äî</span>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="ptt" class="danger" onmousedown="pttStart()" onmouseup="pttStop()"
                ontouchstart="pttStart(event)" ontouchend="pttStop(event)">üéôÔ∏è Talk (hold)</button>
        <span class="muted">Hold to send your mic</span>
      </div>
    </div>

    <div class="card">
      <div><b>Users</b></div>
      <div id="users" class="users">‚Äî</div>
    </div>

    <div class="card">
      <div><b>Debug</b></div>
      <div id="debug" class="log"></div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ---------- minimal globals ----------
    let socket = null;
    let roomId = null;
    let localStream = null;
    let localTrack = null;
    let audioCtxUnlocked = false;

    // peer maps
    const peers = new Map();        // id -> RTCPeerConnection
    const senders = new Map();      // id -> RTCRtpSender  (audio)
    const audios  = new Map();      // id -> <audio> element

    // STUN only
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // ---------- UI helpers ----------
    const el = id => document.getElementById(id);
    function log(...args){ const d=el('debug'); const line=args.map(a=>typeof a==='string'?a:JSON.stringify(a)).join(' '); d.textContent += line + "\n"; d.scrollTop=d.scrollHeight; }
    function setStatus(txt, cls=''){ const n=el('status'); n.textContent=txt; n.className='pill '+cls; }
    function listUsers(list){ el('users').textContent = (list||[]).map(u=>`${u.username}${u.id===socket.id?' (you)':''}`).join(' | ') || '‚Äî'; }

    // ---------- sound unlock ----------
    async function enableSound(){
      try{
        // create/resume AudioContext to satisfy autoplay policies
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (ctx.state === 'suspended') await ctx.resume();
        // also poke any remote <audio> to start later without user gesture
        audioCtxUnlocked = true;
        document.addEventListener('click', unlockMediaOnce, { once:true, capture:true });
        log('sound unlocked');
      }catch(e){ log('unlock error', e); }
    }
    function unlockMediaOnce(){
      audios.forEach(a => a.play().catch(()=>{}));
    }

    // ---------- mic ----------
    async function ensureMic(){
      if (localTrack) return;
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: { channelCount:1, sampleRate:48000, echoCancellation:false, noiseSuppression:false, autoGainControl:false },
        video: false
      });
      localStream = stream;
      localTrack  = stream.getAudioTracks()[0];
      log('mic ready');
    }

    // ---------- signaling ----------
    function bootSocket(){
      socket = io({ transports:['websocket','polling'], reconnection:true });
      socket.on('connect',   ()=> setStatus('socket: connected','ok'));
      socket.on('disconnect',()=> setStatus('socket: disconnected','bad'));
      socket.on('connect_error', (e)=> { setStatus('socket: error','bad'); log('connect_error', e.message||e); });

      socket.on('joined-room', ({ roomId:rid, users }) => {
        roomId = rid;
        listUsers(users);
        log('joined-room', rid, 'users:', users.length);

        // IMPORTANT: polite strategy ‚Äî ONLY existing peers create offers to the new joiner.
        // So on "joined-room" (we are the new joiner), we DO NOT create any offers.
      });

      socket.on('user-joined', ({ user, users }) => {
        listUsers(users);
        log('user-joined', user.id);
        if (user.id !== socket.id) createOfferTo(user.id); // we were already in the room -> we initiate
      });

      socket.on('user-left', ({ id }) => {
        log('user-left', id);
        destroyPeer(id);
        listUsers(); // will refresh on next users-updated too
      });

      socket.on('users-updated', ({ users }) => listUsers(users));

      socket.on('pong', (ts) => {
        const ms = Date.now() - ts;
        const cls = ms<20?'ok':ms<50?'warn':'bad';
        el('rtt').textContent = `rtt: ${ms}ms`;
        el('rtt').className = 'pill '+cls;
      });

      socket.on('signal', async ({ from, data }) => {
        let pc = peers.get(from);
        if (!pc) pc = await createPeer(from, false); // non-initiator if we didn't start it

        try{
          if (data.sdp){
            await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            if (data.sdp.type === 'offer'){
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              socket.emit('signal', { to: from, roomId, data: { sdp: pc.localDescription } });
              log('answered to', from);
            }
          } else if (data.candidate){
            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
          }
        }catch(e){ log('signal error', e.message||e); }
      });
    }

    // ---------- room actions ----------
    function join(){
      const rid = el('room').value.trim().toUpperCase();
      const name = el('name').value.trim() || 'user';
      if (!rid) return;
      socket.emit('join-room', { roomId: rid, username: name, instrument: 'guitar' });
      log('join sent', rid);
    }

    function ping(){
      el('rtt').textContent = 'rtt: ‚Ä¶';
      socket.emit('ping', Date.now());
    }

    // ---------- PTT ----------
    async function pttStart(ev){
      if (ev) ev.preventDefault();
      if (!roomId) return;
      el('ptt').disabled = true;
      try{
        await ensureMic();
        // swap mic track onto every sender (no renegotiation)
        for (const sender of senders.values()){
          await sender.replaceTrack(localTrack);
        }
        if (audioCtxUnlocked) unlockMediaOnce();
        socket.emit('toggle-audio', true);
      }catch(e){ log('pttStart error', e.message||e); }
      el('ptt').disabled = false;
    }
    async function pttStop(ev){
      if (ev) ev.preventDefault();
      // remove track but keep transceivers alive
      for (const sender of senders.values()){
        try{ await sender.replaceTrack(null); }catch{}
      }
      socket.emit('toggle-audio', false);
    }

    // ---------- WebRTC core ----------
    async function createPeer(peerId, initiator){
      const pc = new RTCPeerConnection(rtcConfig);
      peers.set(peerId, pc);

      // one audio transceiver per peer so we can replaceTrack without renegotiation
      const transceiver = pc.addTransceiver('audio', { direction: 'sendrecv' });
      senders.set(peerId, transceiver.sender);

      pc.onicecandidate = (e)=>{ if (e.candidate) socket.emit('signal', { to: peerId, roomId, data: { candidate: e.candidate } }); };
      pc.onconnectionstatechange = ()=> log('pc state', peerId, pc.connectionState);
      pc.oniceconnectionstatechange = ()=> log('ice state', peerId, pc.iceConnectionState);
      pc.ontrack = (ev)=>{
        let a = audios.get(peerId);
        if (!a){
          a = document.createElement('audio');
          a.autoplay = true; a.playsInline = true;
          document.body.appendChild(a);
          audios.set(peerId, a);
        }
        a.srcObject = ev.streams[0];
        a.play().catch(()=>{}); // might still need user gesture -> use "Enable sound"
        log('ontrack from', peerId);
      };

      if (initiator){
        const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: false });
        await pc.setLocalDescription(offer);
        socket.emit('signal', { to: peerId, roomId, data: { sdp: pc.localDescription } });
        log('offer ->', peerId);
      }
      return pc;
    }

    async function createOfferTo(peerId){
      if (peers.has(peerId)) return peers.get(peerId);
      return createPeer(peerId, true);
    }

    function destroyPeer(peerId){
      const pc = peers.get(peerId);
      if (pc){ try{ pc.close(); }catch{} }
      peers.delete(peerId);
      senders.delete(peerId);
      const a = audios.get(peerId);
      if (a){ a.srcObject=null; a.remove(); audios.delete(peerId); }
    }

    // ---------- boot ----------
    document.addEventListener('DOMContentLoaded', ()=>{
      bootSocket();
      // small helper to uppercase room code & strip junk
      el('room').addEventListener('input', e => {
        const v = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g,'').slice(0,12);
        if (v !== e.target.value) e.target.value = v;
      });
      // prevent long-press context menu on PTT
      el('ptt').addEventListener('contextmenu', e => e.preventDefault());
    });
  </script>
</body>
</html>
