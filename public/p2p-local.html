<script>
// …keep everything else as-is…

function sdpTightenOpus(sdp){
  const lines = sdp.split('\r\n');
  let opusPt = null;

  // 1) find opus payload type (a=rtpmap:<pt> opus/48000 …)
  for (const l of lines){
    if (!l.startsWith('a=rtpmap:')) continue;
    // a=rtpmap:<pt> <name>
    // ex: a=rtpmap:111 opus/48000/2
    const parts = l.slice('a=rtpmap:'.length).trim().split(/\s+/);
    const pt = parts[0];
    const name = (parts[1] || '').toLowerCase();
    if (name.startsWith('opus/48000')) { opusPt = pt; break; }
  }
  if (!opusPt) return sdp;

  // 2) force m=audio line to list *only* opus payload first/only
  for (let i=0;i<lines.length;i++){
    const l = lines[i];
    if (l.startsWith('m=audio ')){
      // m=audio <port> <proto> <pts...>
      const segs = l.split(' ');
      if (segs.length >= 4){
        const head = segs.slice(0,3).join(' ');
        lines[i] = `${head} ${opusPt}`;
      }
    }
  }

  // 3) ensure/replace fmtp for opus with our tuned params
  const fmtpLine = `a=fmtp:${opusPt} stereo=0;sprop-stereo=0;ptime=3;minptime=3;maxptime=10;maxaveragebitrate=128000;useinbandfec=1;usedtx=0;cbr=0`;
  let replaced = false;
  for (let i=0;i<lines.length;i++){
    if (lines[i].startsWith(`a=fmtp:${opusPt}`)){ lines[i] = fmtpLine; replaced = true; break; }
  }
  if (!replaced) lines.push(fmtpLine);

  return lines.join('\r\n');
}

// keep this one (it already avoids regex)
function keepHostCandidates(sdp){
  return sdp.split('\r\n')
    .filter(l => !l.startsWith('a=candidate:') || l.includes(' typ host '))
    .join('\r\n');
}

// …keep everything else as-is…
</script>
